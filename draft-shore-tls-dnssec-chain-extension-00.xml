<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc1035 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.1035.xml">
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc4034 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4034.xml">
<!ENTITY rfc4035 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4035.xml">
<!ENTITY rfc4366 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4366.xml">
<!ENTITY rfc5011 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5011.xml">
<!ENTITY rfc5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY rfc6066 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6066.xml">
<!ENTITY rfc6698 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6698.xml">
]>

<!-- To do: -->
<!--   check w/Adam Langley about including him as author -->
<!--   verify that "length - 16" is a valid construction -->
<!--   state machine diagram for the verification section? -->
<!--   do we need to do anything about dnae records? -->


<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc docName="draft-shore-tls-dnssec-chain-extension"
     ipr="trust200902" category="std">

<front>
  <title abbrev="TLS DNSSEC Chain Extension">
    A DNSSEC and DANE Record Validation Chain Extension for TLS
  </title>
  <author fullname="Melinda Shore" initials="M"
          surname="Shore">
    
    <organization>No Mountain Software</organization>
    <address>
      <email>melinda.shore@nomountain.net</email>
    </address>
  </author>

  <author fullname="Richard Barnes" initials="R"
          surname="Barnes">
    <organization>Mozilla</organization>
    <address>
      <email>rlb@ipv.sx</email>
    </address>
  </author>

  <author fullname="Shumon Huque" initials="S"
          surname="Huque">
    <organization>Verisign Labs</organization>
    <address>
      <email>shuque@verisign.com</email>
    </address>
  </author>

  <date year="2015" />
  <area>Security</area>
  <workgroup>TLS</workgroup>
  <abstract>
    <t>
      This draft describes a new TLS v1.2
      extension for transport of a DNS record serialized
      with all the DNSSEC signatures needed to authenticate
      that record.
      The intent of this proposal is to allow TLS clients to
      perform DANE authentication of a TLS server without needing to
      perform additional DNS record lookups. It also avoids potential
      problems with TLS clients being unable to lookup DANE records
      because of an interfering middlebox. And lastly, it allows TLS
      clients to validate DANE records without needing access to a
      validating resolver.
    </t>
  </abstract>
</front>

<middle>
  <section title="Requirements Notation">
    <t>The key words "MUST", "MUST NOT", "REQUIRED",
    "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
    "RECOMMENDED", "MAY", and "OPTIONAL" in this document
    are to be interpreted as described
    in <xref target="RFC2119" />.</t>
  </section>


  <section title="Introduction">
    <t>
      This draft describes
      a new <xref target="RFC5246">TLS v1.2</xref>
      <xref target="RFC6066">extension</xref>
      for transport of a DNS record serialized
      with all of the <xref target="RFC4034">DNSSEC signatures</xref> 
      needed to authenticate that record. 
      The intent of this proposal is to allow TLS clients to 
      perform <xref target="RFC6698">DANE authentication</xref> of a 
      TLS server without needing to
      perform additional DNS record lookups and incurring the
      associated latency penalty. It also avoids potential 
      problems with TLS clients being unable to lookup DANE records
      because of an interfering or broken middlebox. Ideally 
      misbehaving middleboxes should be repaired but as a practical
      matter it is not possible to do so at the scale of today's
      Internet in a reasonable amount of time, so a solution to
      workaround this problem is needed for clients that are stuck
      behind them. And lastly, it allows a TLS client to 
      validate DANE records itself without needing access to
      a validating DNS resolver to which it has a secure connection.
    </t>

    <t>
      Application adoption advice: this mechanism is useful for
      TLS applications that need to address the problems described 
      above. It may not be relevant for many other applications. For
      example, SMTP MTAs are usually located in data centers and not
      behind broken middleboxes, they can tolerate extra DNS lookup
      latency, and are on servers where it is easier to provision
      a validating resolver. Hence <xref target="DANESMTP">DANE 
      authentication of SMTP MTAs</xref> is not likely to make use 
      of this mechanism.
    </t>

    <t>
      The extension described here allows a TLS client to
      request in the client hello message that the DNS validation 
      chain be returned in the (extended) server hello message.
      If the server is configured for DANE authentication, then
      it performs the appropriate DNS queries, builds the validation
      chain, and returns it to the client. Most of the time the 
      server will return a previously cached validation chain, but
      it will need to rebuild it periodically as described in
      <xref target="sec_caching" />. 
      The client then authenticates the chain using a pre-configured 
      trust anchor.
    </t>

    <t>
      This specification builds on Adam Langley's <xref target="AGL">
      earlier proposal for serializing DNSSEC validation chains</xref>,
      from which it incorporates some ideas and text. It modifies the
      approach by using a sequence of DNS records in uncompressed
      DNS wire format instead of a custom serialization format. It 
      also refers more extensively to official DNSSEC protocol documents
      for descriptions of how to perform DNSSEC validation rather than
      describing a validation algorithm in the document, which runs the
      risk of diverging later from the official DNSSEC protocol
      specifications. This new approach makes it easier for implementers
      to use DNS specific libraries to implement these functions, and
      greatly reduces the possibility of implementation errors. An
      appendix to be provided in a later revision of this document will
      include sample code to show one way to do this.
    </t>

  </section> <!-- introduction -->

  <section title="DNSSEC Validation Chain Extension">
    <section title="Protocol">

    <t>
      A client MAY include an extension of type
      "dnssec_chain" in the (extended) ClientHello.  The
      "extension_data" field of this extension MUST be
      empty.
    </t>

    <t>
      Servers receiving a "dnssec_chain" extension in the
      client hello SHOULD return a serialized validation chain
      in the extended ServerHello message, using the format
      described below.  If a server is unable to return a
      validation chain, or does not wish to return a
      validation chain, it returns an empty "dnssec_chain"
      structure - this makes it easy to probe whether a TLS
      server implementation supports this extension or not.
    </t>

    <t>
      Note that any messages associated with these
      extensions that are sent during the TLS handshake MUST
      be included in the hash calculations involved in
      "Finished" messages.
    </t>
    
    </section> <!-- protocol -->

    <section title="DNSSEC Validation Chain Data">

      <t>
	The "extension_data" field of the "dnssec_chain"
        extension (36) contains a sequence of uncompressed wire
	format DNS records.
      </t>

      <figure>
        <artwork>

[First describe here a TLS data structure that treats the
entire validation chain as a single opaque binary blob.]

opaque ValidationChain&lt;0..2^16-1&gt;;

[Question: should we have version number, in case the format
changes in the future?]

[Then describe what the blob contains in terms of the
sequence of DNS records:]

We want something like a sequence of:

Trust anchor DNSKEY, RRSIG(Trust anchor DNSKEY)
* For every intervening delegation:
  DS, RRSIG(DS)
  DNSKEY, RRSIG(DNSKEY)
TLSA, RRSIG(TLSA)

So for the HTTPS server at www.example.com, where there are zone
cuts at "com." and "example.com.", we might get the 
following record sets, each with accompanying RRSIGs:

. DNSKEY
com. DS
com. DNSKEY
example.com. DS
example.com. DNSKEY
_443._tcp.www.example.com. TLSA

[Note: check what format existing DNS libraries return already,
like the validation_chain function in getdns]

        </artwork>
      </figure>

   <t>
     MORE DESCRIPTION TO BE FILLED IN.
   </t>

    </section> <!-- validation chain data -->

  </section> <!-- dnssec validation chain extension -->


  <section title="Construction of Serialized Validation
                  Chains">

    <t>
      This section describes a possible procedure for the server
      to build the serialized DNSSEC chain. 
    </t>

    <t>When the goal is to perform DANE authentication 
       <xref target="RFC6698" /> of the 
       server's X.509 certificate, the DNS record to be
       serialized is a TLSA record corresponding to the 
       server's domain name.
    </t>

    <t>
      The domain name of the server SHOULD be that included in
      the TLS Server Name Indication extension
      <xref target="RFC4366" /> when present. If the Server Name 
      Indication extension is not present, or if the server does not 
      recognize the provided name and wishes to proceed with the handshake 
      rather than aborting the connection, the server uses the
      domain name associated with the server IP address that the TLS
      connection arrives on. [Question: to simplify, we could mandate 
      the use of SNI as a precondition to using this extension. Almost
      all modern TLS clients use SNI, so this should not be a big issue.]
    </t>

    <t>
      The TLSA record to be queried is constructed by prepending
      the _port and _transport labels to the domain name as described
      in <xref target="RFC6698" />, where port is the port number
      associated with the TLS server, and transport is usually "tcp"
      for TLS servers. [Question: does this specification permit use
      by DTLS servers too?]
    </t>

    <t>
      Note: In updated versions of this specification, the use of 
      other DANE style records may be described for TLS applications 
      that may make use of them.
    </t>

    <t>
      The components of the validation chain series are built by
      starting at the trust anchor DNSKEY (usually expected to be
      the DNS root trust anchor) and its corresponding RRSIG 
      signature record, and then for each intervening zone cut, 
      adding the DS record and DNSKEY records and their RRSIGs, and 
      finally the target TLSA record and RRSIG.
    </t>
    <t>
      Records in the validation chain are stored in uncompressed
      DNS wire format. DNS response packets contain wire format
      records, but domain names in them can be "compressed" as
      described in <xref target="RFC1035" /> by replacing a domain
      name or a list of trailing labels with a pointer to a prior 
      occurrence of the same name in the DNS packet. In the
      construction of the validation chain, DNS records MUST be
      uncompressed. Note: A future version of this specification may
      outline a method to compress domain names in the validation
      chain (by employing similar pointers to previous locations)
      to save space, but the current specification uses uncompressed
      domain names only.
    </t>
    <t>
      [Question: (for the future): should we consider the use of
      traditional compression algorithms like those used by gzip,
      bzip2, xz, etc, rather than contemplating a new label
      compression scheme for a serialized chain? This probably
      needs an evaluation first of how compressible wire form
      domain names are using those algorithms.]
    </t>
    <t>
      If the server acts as its own full  iterative DNS resolver, 
      it can just build the chain as it performs normal iterative 
      resolution of the target record. If the server uses a 
      recursive server (which is expected to be a more common case),
      it employs a slightly modified lookup algorithm. The modified
      algorithm starts at the trust anchor, gradually prepends additional
      labels and looks for NS, DS, and DNSKEY records, until it 
      reaches the target name. [SPELL OUT MORE PRECISE DETAILS HERE, OR 
      PROVIDE AN ALGORITHM IN AN APPENDIX?]
    </t>

  </section> <!-- construction -->


  <section title="Caching and Regeneration of the Validation Chain"
	   anchor="sec_caching">
    <t>
      DNS records have Time To Live (TTL) parameters, and DNSSEC
      signatures have validity periods (specifically signature expiration
      times). After the TLS server constructs the serialized validation
      chain, it can cache and reuse it in multiple TLS connection
      handshakes. However, it should keep track of the TTLs and signature
      validity periods and requery the records and rebuild the validation
      chain as needed. A server implementation could carefully track
      these parameters and requery the chain correspondingly. Alternatively, 
      it could be configured to rebuild the chain at some predefined periodic
      intervals.
    </t>
  </section>


  <section title="Verification" anchor="sec_verification">

    <t>
      [Question: Should we rename this section "Validation" to be more
      consistent with terminology used in DNS?]
    </t>
    <t>
      A TLS client making use of this specification, and which receives
      a DNSSEC validation chain extension from a server, SHOULD use this
      information to perform DANE authentication of the server certificate.
      In order to do this, it provides the chain and its configured trust
      anchor to a DNSSEC validation engine or library, which performs 
      validation according to the 
      <xref target="RFC4035">DNSSEC protocol</xref>.
      If the record is correctly authenticated, it then performs DANE
      authentication according to the 
      <xref target="RFC6698">DANE TLS protocol</xref>.
      [More details needed?]
    </t>

  </section> <!-- verification -->


  <section title="Trust Anchor Maintenance" anchor="sec_trustmaint">

    <t>
      The trust anchor could periodically change, e.g. due to a
      key rollover event by the operator of the initial zone. Managed 
      key rollovers typically use a process that can be tracked by 
      verifiers allowing them to automatically update their trust 
      anchors, as described in <xref target="RFC5011" />. TLS clients 
      using this specification are also expected to use such a mechanism 
      to keep their trust anchors updated. Some operating systems may 
      have a system wide service to maintain and keep up-to-date the 
      root trust anchor, and it may be possible for the TLS client 
      application to simply reference that as its trust anchor,
      periodically checking whether it has changed.
    </t>

  </section>


  <section title="Other Considerations" anchor="sec_other">

    <t>
      [Does the accurate time issue belong in Security Considerations?]
    </t>
    <t>
      DNSSEC signatures have validity periods defined by an inception
      and expiration time. 
      TLS clients need roughly accurate time in order to properly
      authenticate these signatures. This could be achieved by running
      a time synchronization protocol like NTP (reference?) or SNTP,
      which are already widely used today.
    </t>
    <t>
      Would another option be the following?: assume the TLS
      server has accurate time, extract the remote time from the
      TLS handshake, and use that? There are tools that synchronize
      time in this way already (see "tlsdate"). However, this might
      be vulnerable to a minor attack: A malicious TLS server, before
      it's been DANE authenticated, could provide a false time, in 
      order to trick a client into accepting a previously valid 
      signed DNS record (i.e. a replay attack).
    </t>

  </section> <!-- verification -->


  <section title="Security Considerations">
    <t>Security considerations covered in <xref
       target="RFC6066" /> apply here, as well.</t>
  </section>

  <section title="IANA Considerations">
    <t>This extension requires the registration of a new
      value in the TLS ExtensionsType registry.  For
      temporary use during initial implementation efforts,
      the "dnssec_chain" extension will take the value 36.</t>
  </section> <!-- iana considerations -->

  <section title="Acknowledgments">
    <t>
      Many thanks to Adam Langley for laying the groundwork
      for this extension. This document also benefited from 
      discussions with the following people: Allison Mankin
      and Duane Wessels.
    </t>
  </section>

  <section title="Test Vectors">

    <t>
      [TO BE ADDED LATER. THE ORIGINAL CONTENT WAS OBSOLETE.]
    </t>

  </section> <!-- test vectors -->


</middle>

<back>

  <references title="Normative References">
    &rfc1035;
    &rfc2119;
    &rfc4034;
    &rfc4035;
    &rfc4366;
    &rfc5011;
    &rfc5246;
    &rfc6066;
    &rfc6698;
    <reference anchor="DANESMTP"
      target="https://tools.ietf.org/html/draft-ietf-dane-smtp-with-dane-19">
      <front>
        <title>SMTP Security via opportunistic DANE TLS</title>
        <author fullname="Viktor Dukhovni" initials="V" surname="Dukhovni" />
        <author fullname="Wes Hardaker" initials="W" surname="Hardaker" />
      </front>
    </reference>
  </references>

  <references title="Informative References">
    <reference anchor="AGL"
	       target="https://tools.ietf.org/id/draft-agl-dane-serializechain-01.txt">
      <front>
        <title>Serializing DNS Records with DNSSEC Authentication</title>
        <author fullname="Adam Langley" initials="A" surname="Langley" />
        <organization>Google, Inc</organization>
      </front>
    </reference>
  </references>

</back>
</rfc>
