<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc4034 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4034.xml">
<!ENTITY rfc4035 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4035.xml">
<!ENTITY rfc4366 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4366.xml">
<!ENTITY rfc5011 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5011.xml">
<!ENTITY rfc5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY rfc6066 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6066.xml">
<!ENTITY rfc6698 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6698.xml">
]>

<!-- To do: -->
<!--   check w/Adam Langley about including him as author -->
<!--   verify that "length - 16" is a valid construction -->
<!--   state machine diagram for the verification section? -->
<!--   do we need to do anything about dnae records? -->


<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc docName="draft-shore-tls-dnssec-chain-extension"
     ipr="trust200902" category="std">

<front>
  <title abbrev="TLS DNSSEC Chain Extension">
    A DNSSEC and DANE Record Validation Chain Extension for TLS
  </title>
  <author fullname="Melinda Shore" initials="M"
          surname="Shore">
    
    <organization>No Mountain Software</organization>
    <address>
      <email>melinda.shore@nomountain.net</email>
    </address>
  </author>

  <author fullname="Richard Barnes" initials="R"
          surname="Barnes">
    <organization>Mozilla</organization>
    <address>
      <email>rlb@ipv.sx</email>
    </address>
  </author>

  <author fullname="Shumon Huque" initials="S"
          surname="Huque">
    <organization>Verisign Labs</organization>
    <address>
      <email>shuque@verisign.com</email>
    </address>
  </author>

  <date year="2015" />
  <area>Security</area>
  <workgroup>TLS</workgroup>
  <abstract>
    <t>
      This draft describes a new TLS v1.2
      extension for transport of a DNS record serialized
      with all the DNSSEC signatures needed to authenticate
      that record.
      The intent of this proposal is to allow TLS clients to
      perform DANE authentication of a TLS server without needing to
      perform additional DNS record lookups. It also avoids potential
      problems with TLS clients being unable to lookup DANE records
      because of an interfering middlebox. And lastly, it allows TLS
      clients to validate DANE records without needing access to a
      validating resolver.
    </t>
  </abstract>
</front>

<middle>
  <section title="Requirements Notation">
    <t>The key words "MUST", "MUST NOT", "REQUIRED",
    "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
    "RECOMMENDED", "MAY", and "OPTIONAL" in this document
    are to be interpreted as described
    in <xref target="RFC2119" />.</t>
  </section>


  <section title="Introduction">
    <t>
      This draft describes
      a new <xref target="RFC5246">TLS v1.2</xref>
      <xref target="RFC6066">extension</xref>
      for transport of a DNS record serialized
      with all of the DNSSEC signatures needed to authenticate
      that record. 
      The intent of this proposal is to allow TLS clients to 
      perform DANE authentication of a TLS server without needing to
      perform additional DNS record lookups and incurring the
      associated latency penalty. It also avoids potential 
      problems with TLS clients being unable to lookup DANE records
      because of an interfering or broken middlebox. Ideally 
      misbehaving middleboxes should be repaired but as a practical
      matter it is not possible to do so at the scale of today's
      Internet in a reasonable amount of time, so a solution to
      workaround this problem is needed for clients that are stuck
      behind them. And lastly, it allows a TLS client to 
      validate DANE records itself without needing access to
      a validating DNS resolver to which it has a secure connection.
    </t>

    <t>
      The extension described here allows a TLS client to
      request in the client hello message that the DNS validation 
      chain be returned in the (extended) server hello message.
      If the server is configured for DANE authentication, then
      it performs the appropriate DNS queries, builds the validation
      chain, and returns it to the client. Most of the time the 
      server will return a previously cached validation chain, but
      it will need to rebuild it periodically as described in
      <xref target="sec_caching" />. 
      The client then authenticates the chain using a pre-configured 
      trust anchor.
    </t>

    <t>
      This specification builds on Adam Langley's <xref target="AGL">
      earlier proposal for serializing DNSSEC validation chains</xref>,
      from which it incorporates some ideas and text. It modifies the
      approach by using a sequence of DNS records in uncompressed
      DNS wire format instead of a custom serialization format. It 
      also refers more extensively to official DNSSEC protocol documents
      for descriptions of how to perform DNSSEC validation rather than
      describing a validation algorithm in the document, which runs the
      risk of diverging later from the official DNSSEC protocol
      specifications. This new approach makes it easier for implementers
      to use DNS specific libraries to implement these functions, and
      greatly reduces the possibility of implementation errors. An
      appendix to be provided in a later revision of this document will
      include sample code to show one way to do this.
    </t>

  </section> <!-- introduction -->

  <section title="DNSSEC Validation Chain Extension">
    <section title="Protocol">

    <t>
      A client MAY include an extension of type
      "dnssec_chain" in the (extended) ClientHello.  The
      "extension_data" field of this extension MUST be
      empty.
    </t>

    <t>
      Servers receiving a "dnssec_chain" extension in the
      client hello SHOULD return a serialized validation chain
      in the extended ServerHello message, using the format
      described below.  If a server is unable to return a
      validation chain, or does not wish to return a
      validation chain, it returns an empty "dnssec_chain"
      structure - this makes it easy to probe whether a TLS
      server supports this extension or not.
    </t>

    <t>
      Note that any messages associated with these
      extensions that are sent during the TLS handshake MUST
      be included in the hash calculations involved in
      "Finished" messages.
    </t>
    
    </section> <!-- protocol -->

    <section title="DNSSEC Validation Chain Data">

      <t>
	The "extension_data" field of the "dnssec_chain"
        extension (36) contains a sequence of uncompressed wire
	format DNS records.
      </t>

      <figure>
        <artwork>

We want something like a sequence of:

Trust anchor DNSKEY, RRSIG(Trust anchor DNSKEY)
* For every intervening delegation:
  DS, RRSIG(DS)
  DNSKEY, RRSIG(DNSKEY)
TLSA, RRSIG(TLSA)

So for the HTTPS server at www.example.com, we might get the 
following record sets, each with accompanying RRSIGs:

. DNSKEY
com. DS
com. DNSKEY
example.com. DS
example.com. DNSKEY
_443._tcp.www.example.com. TLSA

        </artwork>
      </figure>

   <t>
     MORE DESCRIPTION TO BE FILLED IN.
   </t>

    </section> <!-- validation chain data -->

  </section> <!-- dnssec validation chain extension -->


  <section title="Construction of Serialized Validation
                  Chains">

    <t>
      This section describes a possible procedure for the server
      to build the serialized DNSSEC chain. 
    </t>

    <t>When the goal is to perform DANE authentication 
       <xref target="RFC6698" /> of the 
       server's X.509 certificate, the DNS record to be
       serialized is a TLSA record corresponding to the 
       server's domain name.
    </t>

    <t>
      The domain name of the server SHOULD be that included in
      the TLS Server Name Indication extension
      <xref target="RFC4366" /> when present. If the Server Name 
      Indication extension is not present, or if the server does not 
      recognize the provided name and wishes to proceed with the handshake 
      rather than aborting the connection, the server uses the
      domain name associated with the server IP address that the TLS
      connection arrives on. [Question: to simplify, we could mandate 
      the use of SNI as a precondition to using this extension. Almost
      all modern TLS clients use SNI, so this should not be a big issue.]
    </t>

    <t>
      The TLSA record to be queried is constructed by prepending
      the _port and _transport labels to the domain name as described
      in <xref target="RFC6698" />, where port is the port number
      associated with the TLS server, and transport is usually "tcp"
      for TLS servers. [Question: does this specification permit use
      by DTLS servers too?]
    </t>

    <t>
      Note: In updated versions of this specification, the use of 
      other DANE style records may be described for TLS applications 
      that may make use of them.
    </t>

    <t>
      [INSERT NEW TEXT HERE ABOUT A CLEANER WAY TO PERFORM TOP
      DOWN CONSTRUCTION OF THE DNS QUERIES USING THE NORMAL WAY
      A DNS RESOLVER MIGHT DO IT. IF THE SERVER CAN ACT AS A FULL
      ITERATIVE RESOLVER, IT CAN JUST IMPLEMENT THE FULL ITERATIVE
      RESOLUTION ALGORITHM AND CONSTRUCT THE CHAIN AS IT GOES. IF
      THE SERVER USES A RECURSIVE SERVER, THEN A SLIGHTLY MODIFIED
      LOOKUP ALGORITHM IS NEEDED - SPELL THAT OUT.]
    </t>

  </section> <!-- construction -->


  <section title="Caching and Regeneration of the Validation Chain"
	   anchor="sec_caching">
    <t>
      DNS records have Time To Live (TTL) parameters, and DNSSEC
      signatures have validity periods (specifically signature expiration
      times). After the TLS server constructs the serialized validation
      chain, it can cache and reuse it in multiple TLS connection
      handshakes. However, it should keep track of the TTLs and signature
      validity periods and requery the records and rebuild the validation
      chain as needed. A server implementation could carefully track
      these parameters and requery the chain correspondingly. Alternatively, 
      it could be configured to rebuild the chain at some predefined periodic
      intervals.
    </t>
  </section>


  <section title="Verification" anchor="sec_verification">

    <t>
      [PLACEHOLDER: Here will mostly refer to official DNSSEC protocol specs
      for how to do validation, given a received DNSSEC validation chain,
      and a configured trust anchor.]
    </t>

  </section> <!-- verification -->


  <section title="Trust Anchor Maintenance" anchor="sec_trustmaint">

    <t>
      The trust anchor could periodically change, e.g. due to a
      key rollover event by the operator of the initial zone. Managed 
      key rollovers typically use a process that can be tracked by 
      verifiers allowing them to automatically update their trust 
      anchors, as described in <xref target="RFC5011" />. TLS clients 
      using this specification are also expected to use such a mechanism 
      to keep their trust anchors updated. Some operating systems may 
      have a system wide service to maintain and keep up-to-date the 
      root trust anchor, and it may be possible for the TLS client 
      application to simply reference that as its trust anchor,
      periodically checking whether it has changed.
    </t>

  </section>


  <section title="Other Considerations" anchor="sec_other">

    <t>
      [Reasonably accurate time is needed on clients to be able to 
      properly validate DNSSEC signatures which have signature
      inception and expiration parameters. Do we recommend using
      NTP?]

    </t>

  </section> <!-- verification -->


  <section title="Security Considerations">
    <t>Security considerations covered in <xref
       target="RFC6066" /> apply here, as well.</t>
  </section>

  <section title="IANA Considerations">
    <t>This extension requires the registration of a new
      value in the TLS ExtensionsType registry.  For
      temporary use during initial implementation efforts,
      the "dnssec_chain" extension will take the value 36.</t>
  </section> <!-- iana considerations -->

  <section title="Acknowledgments">
    <t>Many thanks to Adam Langley for laying the groundwork
      for this extension.</t>
  </section>

  <section title="Test Vectors">

    <t>
      [TO BE ADDED LATER. THE ORIGINAL CONTENT WAS OBSOLETE.]
    </t>

  </section> <!-- test vectors -->


</middle>

<back>
  <references title="Normative References">
    <reference anchor="AGL"
      target="https://tools.ietf.org/id/draft-agl-dane-serializechain-01.txt">
      <front>
        <title>Serializing DNS Records with DNSSEC
          Authentication</title>
        <author fullname="Adam Langley" initials="A"
                surname="Langley" />
        <organization>Google, Inc</organization>
      </front>
    </reference>
    &rfc2119;
    &rfc4034;
    &rfc4035;
    &rfc4366;
    &rfc5011;
    &rfc5246;
    &rfc6066;
    &rfc6698;
  </references>
</back>
</rfc>
